
name: Install deps & build

on:
  workflow_call:
    inputs:
      envName:
        description: "'staging' | 'prod'. The deployment environment (needed so we know which Firebase env variables to use)."
        required: true
        type: string  # Must be either 'boolean', 'number', or 'string'    
        # default: "staging"


jobs:
  validate_inputs:
    runs-on: ubuntu-latest
    steps:
      - name: Validate inputs      
        if: ${{ inputs.envName != 'staging'  &&  inputs.envName != 'prod'}} # Inspiration: https://stackoverflow.com/a/70281911/718325
        run: echo "'Required input 'envName' must be set to either 'staging' or 'prod'. You passed '${{ inputs.envName }}'"; exit 1;

  install_deps_and_build:
    needs: [validate_inputs]
    runs-on: ubuntu-latest

    steps:        
      - name: Checkout the commit
        uses: actions/checkout@v2

      - name: Install dependencies
        run: npm ci
        # working-directory: ./frontend

      - name: Building the app for 'staging'
        if:  ${{ inputs.envName == 'staging' }}
        run: npm run build
        # working-directory: ./frontend
        env:
          NEXT_PUBLIC__FIREBASE_CONFIG__API_KEY:             ${{ secrets.STAGING__NEXT_PUBLIC__FIREBASE_CONFIG__API_KEY }}
          NEXT_PUBLIC__FIREBASE_CONFIG__AUTH_DOMAIN:         ${{ secrets.STAGING__NEXT_PUBLIC__FIREBASE_CONFIG__AUTH_DOMAIN }}
          NEXT_PUBLIC__FIREBASE_CONFIG__PROJECT_ID:          ${{ secrets.STAGING__NEXT_PUBLIC__FIREBASE_CONFIG__PROJECT_ID }}
          NEXT_PUBLIC__FIREBASE_CONFIG__STORAGE_BUCKET:      ${{ secrets.STAGING__NEXT_PUBLIC__FIREBASE_CONFIG__STORAGE_BUCKET }}
          NEXT_PUBLIC__FIREBASE_CONFIG__MESSAGING_SENDER_ID: ${{ secrets.STAGING__NEXT_PUBLIC__FIREBASE_CONFIG__MESSAGING_SENDER_ID }}
          NEXT_PUBLIC__FIREBASE_CONFIG__APP_ID:              ${{ secrets.STAGING__NEXT_PUBLIC__FIREBASE_CONFIG__APP_ID }}
          NEXT_PUBLIC__FIREBASE_CONFIG__MEASUREMENT_ID:      ${{ secrets.STAGING__NEXT_PUBLIC__FIREBASE_CONFIG__MEASUREMENT_ID }}


      - name: Building the app for 'prod'
        if:  ${{ inputs.envName == 'prod' }}
        run: npm run build
        # working-directory: ./frontend
        env:
          NEXT_PUBLIC__FIREBASE_CONFIG__API_KEY:             ${{ secrets.NEXT_PUBLIC__FIREBASE_CONFIG__API_KEY }}
          NEXT_PUBLIC__FIREBASE_CONFIG__AUTH_DOMAIN:         ${{ secrets.NEXT_PUBLIC__FIREBASE_CONFIG__AUTH_DOMAIN }}
          NEXT_PUBLIC__FIREBASE_CONFIG__PROJECT_ID:          ${{ secrets.NEXT_PUBLIC__FIREBASE_CONFIG__PROJECT_ID }}
          NEXT_PUBLIC__FIREBASE_CONFIG__STORAGE_BUCKET:      ${{ secrets.NEXT_PUBLIC__FIREBASE_CONFIG__STORAGE_BUCKET }}
          NEXT_PUBLIC__FIREBASE_CONFIG__MESSAGING_SENDER_ID: ${{ secrets.NEXT_PUBLIC__FIREBASE_CONFIG__MESSAGING_SENDER_ID }}
          NEXT_PUBLIC__FIREBASE_CONFIG__APP_ID:              ${{ secrets.NEXT_PUBLIC__FIREBASE_CONFIG__APP_ID }}
          NEXT_PUBLIC__FIREBASE_CONFIG__MEASUREMENT_ID:      ${{ secrets.NEXT_PUBLIC__FIREBASE_CONFIG__MEASUREMENT_ID }}


      - name: Archive the build (so other jobs can access it)
        uses: actions/upload-artifact@v3 # See this example in the docs: https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts#example
        with:
          # The name we assign to our archive.
          # Next.js calls their build output directory 'out' and our firebase.json file has a field
          #  that also states that (so hosting knows where our files are). So it probably makes sense to name
          #  this archive by the same name.
          # name: out 
          name: build
          # The path to the directory (or directories or files) that we want to archive (see the example noted above)
          # path: |
          #   out          
          path: |
            ./*          
